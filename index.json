[{"authors":null,"categories":null,"content":" Tarant is a TypeScript/JavaScript library for building software using the actor system model. You can visit the home page for more information and a more complete quick start guide: https://www.tarant.io/\n Actors are easy to reason about: An actor is the unit of state and logic of your application. They are transactional, so you don\u0026rsquo;t need to handle state rollbacks in case of errors. Actors improve performance: Asynchronous by default, every actor actual communication is non-blocking so slow actors will not block fast actors. Actors are extensible: As actors are built on top of objects, actor classes can be inherited, composed and injected.  Features Tarant implements a rich set of features that makes it suitable for building complex applications.\n Actors are reliable because they are transactional. You don\u0026rsquo;t need to bother yourself with error recovery. Actors are performant, as they are pull-based and decoupled from other actors lifecycle. Actors are easy to debug. All messages come with information about the sender and all the state information is saved in a time machine, for further debugging and navigation. The Actor System has an event bus. Actors can subscribe, publish and request messages from any topic and subscriptions can be handled at any time. The Actor System is highly extensive. You can add your own supervisor and materializers to add new features like implicit persistence or rendering of actors.  Showcase  Actors support asynchronous messaging and answering through Promises. Slow actors will not block fast actors. Actors can schedule tasks for interval or one-shot delayed actions. Actors are safe and can be recovered with a supervisor. Actors can subscribe in a topic in a type-safe way for extensible communication.  Quick start Creating your first actor system is easy and you don\u0026rsquo;t need to understand everything that is happening under the hood. First you must install the package:\nnpm install tarant --save\nThen create your first ActorSystem\nlet { Actor, ActorSystem } = require('tarant') let system = ActorSystem.default()  And create your actor class:\nclass Ping extends Actor { ping() { console.log(\u0026quot;PING\u0026quot;) } }  Then you only need to instantiate your actor and send messages to it:\nlet myPinger = system.actorOf(Ping, []) myPinger.ping()  The application will continue running and processing messages until you stop the actor system:\nsystem.free()  If you run the application you will see the following output:\nPING  Contribution  PR and issues are always welcome as a quick way of contributing to the project. Remember to be polite, this is a open source project and ordinary requirements for PRs and issues are also a requirement.\nIf you want to be a long-term contributor and participate actively on the design of new features on the project, contact us! Check the package.json to see who you need to contact.\nCreated my free logo at LogoMakr.com ","date":1546041600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1546041600,"objectID":"5eaa8772dcb2dd7c0fa70b23809c57c7","permalink":"http://tarantx.github.io/modules/tarant/","publishdate":"2018-12-29T00:00:00Z","relpermalink":"/modules/tarant/","section":"modules","summary":"Tarant is a TypeScript/JavaScript library for building software using the actor system model. You can visit the home page for more information and a more complete quick start guide: https://www.tarant.io/\n Actors are easy to reason about: An actor is the unit of state and logic of your application. They are transactional, so you don\u0026rsquo;t need to handle state rollbacks in case of errors. Actors improve performance: Asynchronous by default, every actor actual communication is non-blocking so slow actors will not block fast actors.","tags":["tarant"],"title":" Tarant","type":"modules"},{"authors":null,"categories":null,"content":" This example shows how actors can call each other without blocking themselves.\nFeatures used  Async Actors: Async actors with promises are already part of Tarant. Any method that is marked as async will be handled asynchronously and non-blocking by Tarant, and messages are guaranteed to be processed in order.  Live Example See the Pen tarant ping pong example by Kevin Mas Ruiz (@kmruiz) on CodePen.\n\n","date":1545868800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1545868800,"objectID":"85f402d01e7143f6a179d66d2388d47e","permalink":"http://tarantx.github.io/showcases/ping-pong/","publishdate":"2018-12-27T00:00:00Z","relpermalink":"/showcases/ping-pong/","section":"showcases","summary":"This example shows how actors can call each other without blocking themselves.\nFeatures used  Async Actors: Async actors with promises are already part of Tarant. Any method that is marked as async will be handled asynchronously and non-blocking by Tarant, and messages are guaranteed to be processed in order.  Live Example See the Pen tarant ping pong example by Kevin Mas Ruiz (@kmruiz) on CodePen.","tags":null,"title":"Actors playing Ping Pong","type":"showcases"},{"authors":null,"categories":null,"content":" This example demonstrates how Actors process messages independently. When you press the +1 button, you will see how there are two counters, one that updates fast, and one that updates slower.\nLoad is simulated using a sleep function with a setTimeout.\nFeatures used  Topics: Topics encapsulate communication between actors in a fan out basis. Each actor subscribed to a topic will eventually receive messages in guaranteed order. In this specific use case, the +1 button is sending, each time the user clicks on it, a message through a topic. Async Actors: Async actors with promises are already part of Tarant. Any method that is marked as async will be handled asynchronously and non-blocking by Tarant, and messages are guaranteed to be processed in order.  Live Example See the Pen tarant quick-start example by Kevin Mas Ruiz (@kmruiz) on CodePen.\n\n","date":1545868800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1545868800,"objectID":"eec6d4a717dc320d7354f000f44b7503","permalink":"http://tarantx.github.io/showcases/pub-sub/","publishdate":"2018-12-27T00:00:00Z","relpermalink":"/showcases/pub-sub/","section":"showcases","summary":"This example demonstrates how Actors process messages independently. When you press the +1 button, you will see how there are two counters, one that updates fast, and one that updates slower.\nLoad is simulated using a sleep function with a setTimeout.\nFeatures used  Topics: Topics encapsulate communication between actors in a fan out basis. Each actor subscribed to a topic will eventually receive messages in guaranteed order. In this specific use case, the +1 button is sending, each time the user clicks on it, a message through a topic.","tags":null,"title":"PubSub for Actors","type":"showcases"},{"authors":null,"categories":null,"content":" This example shows how actors can schedule the execution of messages dynamically.\nFeatures used  Scheduleds: Scheduleds are handled by actors, are non-blocking and support asynchronous methods.  Live Example See the Pen tarant scheduleds example by Kevin Mas Ruiz (@kmruiz) on CodePen.\n\n","date":1545868800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1545868800,"objectID":"701f96119511a718d2a2082e0db64cee","permalink":"http://tarantx.github.io/showcases/scheduleds/","publishdate":"2018-12-27T00:00:00Z","relpermalink":"/showcases/scheduleds/","section":"showcases","summary":"This example shows how actors can schedule the execution of messages dynamically.\nFeatures used  Scheduleds: Scheduleds are handled by actors, are non-blocking and support asynchronous methods.  Live Example See the Pen tarant scheduleds example by Kevin Mas Ruiz (@kmruiz) on CodePen.","tags":null,"title":"Scheduled Operations","type":"showcases"},{"authors":null,"categories":null,"content":" Tarant is a JavaScript library that implements the Actor Model, which makes concurrent programming easy to understand and maintain. Thus, the most important building block of Tarant is the Actor. This getting started guide will walk you through the basic flow of starting an Actor System (which holds actor references) and your first actor, in a running application.\nSetting up Tarant The only step needed for using Tarant is installing the library. It\u0026rsquo;s already pushed in the npm registry, so you can download it either using npm or yarn:\nnpm install tarant --save  yarn add tarant  Now you are ready to start.\nDefining your first Actor Tarant implements a new building block to ES6, the Actor. Actors are objects that are thread-safe and asynchronous in a way that is transparent to the developer. Actors are managed by the Actor System, which holds references to Actors, so you can create and find them.\nFirst, import tarant into the current file:\nconst { Actor, ActorSystem } = require('tarant')  Now, you can create your first Actor class. Creating an Actor class is like creating an ordinary ES6 class, but you will need to extend Actor.\nWe will create an Actor with a single method, that will print something to the console.\nclass Pinger extends Actor { ping() { console.log('Ping!') } }  Starting an Actor System For using the actor, you will need to create first an Actor System. The actor system is used by all actors in an application, so you usually will need to create it only once and reuse whenever you need it.\nconst system = ActorSystem.default()  Now, you can create a new Actor of type Pinger using your freshly created actor system.\nconst pinger = system.actorOf(Pinger)  Using your actor is as easy as using any other object instance. You can now call the ping method.\npinger.ping()  Freeing the Actor System The application will keep running until you free the actor system. Freeing the actor system will clean up all actor instances and then stop the process, so the application can stop gracefully. To stop the actor system, call the free method on it.\nsystem.free()  What\u0026rsquo;s next There are several features that were not covered in this getting started guide, but they can be useful for complex applications. You can see them in the main documentation and in the showcases page.\nYou can also take a look at the examples repository, to download ready to start examples where you can play and investigate more about actors.\nCodePen If you want to see a similar CodePen, to run the example and change it, feel free to use this one:\nSee the Pen tarant pinger example by Kevin Mas Ruiz (@kmruiz) on CodePen.\n\n","date":1543536000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1543536000,"objectID":"f85aa3ecad9018a932f3d3bc0b0c139b","permalink":"http://tarantx.github.io/tutorial/getting-started/","publishdate":"2018-11-30T00:00:00Z","relpermalink":"/tutorial/getting-started/","section":"tutorial","summary":"Tarant is a JavaScript library that implements the Actor Model, which makes concurrent programming easy to understand and maintain. Thus, the most important building block of Tarant is the Actor. This getting started guide will walk you through the basic flow of starting an Actor System (which holds actor references) and your first actor, in a running application.\nSetting up Tarant The only step needed for using Tarant is installing the library.","tags":null,"title":"Getting Started","type":"tutorial"},{"authors":null,"categories":null,"content":" Actor Systems hold all the information about the location of all the actors on an application, even if they are in memory or not. They are composed of:\n Materializers Resolvers A Top Level Supervisor Fibers Mailboxes  There are two main ways to create an Actor System in tarant. One uses the default configuration, and the other one lets the developer configure most of the advanced fields for customizing the behaviour.\nDefault Configuration Creating an Actor System with the default configuration is just a matter of calling a single static method. Let\u0026rsquo;s assume that you already have a javascript file, first you will need to import the ActorSystem class from the main package:\nconst { ActorSystem } = require('tarant')  After importing the ActorSystem, you will need to call the default static method in ActorSystem and it will return a freshly created ActorSystem with a running, default configuration.\nconst system = ActorSystem.default()  Using Custom Configuration The ActorSystem is a complex object because it has several responsibilities, like the orchestration of different components. To simplify the configuration we provide a configuration builder with a set of methods to change the default configuration. Is worth to note that any not changed field will remain with the default configuration, which is usually enough for most applications.\nTo use the configuration builder, you will need first to import it from the main package:\nconst { ActorSystem, ActorSystemConfigurationBuilder } = require('tarant')  Then you can create your configuration using the builder, as in:\nconst localStorageRepository = new LocalStorageRepository() const configuration = ActorSystemConfigurationBuilder.define() .withMaterializers([new VueRenderer(), localStorageRepository]) // Render actors with vue.js and store their state in the localStorage of the browser .withResolvers([localStorageRepository]) // When a non existing actor is requested, try to resolve them in the localStorage of the browser .done()  And then, call the static constructor named for in the ActorSystem to provide the new configuration:\nconst system = ActorSystem.for(configuration)  Freeing the Actor System You can always stop the Actor System using the provided free method. It will stop all actors and stop all fibers.\nsystem.free()  ","date":1543449600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1543449600,"objectID":"e0ed21fb32818e12c306b0eea682f923","permalink":"http://tarantx.github.io/tutorial/how-to-create-an-actor-system/","publishdate":"2018-11-29T00:00:00Z","relpermalink":"/tutorial/how-to-create-an-actor-system/","section":"tutorial","summary":"Actor Systems hold all the information about the location of all the actors on an application, even if they are in memory or not. They are composed of:\n Materializers Resolvers A Top Level Supervisor Fibers Mailboxes  There are two main ways to create an Actor System in tarant. One uses the default configuration, and the other one lets the developer configure most of the advanced fields for customizing the behaviour.","tags":null,"title":"How To Create an Actor System","type":"tutorial"},{"authors":null,"categories":null,"content":"Actor Systems hold all the information about the location of all the actors on an application, even if they are in memory or not. They are composed of:\n Materializers Resolvers A Top Level Supervisor Fibers Mailboxes  ","date":1543363200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1543363200,"objectID":"6143397ab282aaf4be120e5f2600ef47","permalink":"http://tarantx.github.io/architecture/actor-system/","publishdate":"2018-11-28T00:00:00Z","relpermalink":"/architecture/actor-system/","section":"architecture","summary":"Actor Systems hold all the information about the location of all the actors on an application, even if they are in memory or not. They are composed of:\n Materializers Resolvers A Top Level Supervisor Fibers Mailboxes  ","tags":null,"title":"Actor Systems","type":"architecture"},{"authors":null,"categories":null,"content":"Fibers represent green threads with a set of resources. Usually, an application will contain only one fiber (because JavaScript only exposes one single thread, with an event loop), however, it\u0026rsquo;s possible to have multiple fibers when you are working with webworkers.\nFibers offer CPU ticks to processors, that will use them to process actor mailboxes.\n","date":1543363200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1543363200,"objectID":"6f76b3b0e491325831576f5532904d8c","permalink":"http://tarantx.github.io/architecture/fibers/","publishdate":"2018-11-28T00:00:00Z","relpermalink":"/architecture/fibers/","section":"architecture","summary":"Fibers represent green threads with a set of resources. Usually, an application will contain only one fiber (because JavaScript only exposes one single thread, with an event loop), however, it\u0026rsquo;s possible to have multiple fibers when you are working with webworkers.\nFibers offer CPU ticks to processors, that will use them to process actor mailboxes.","tags":null,"title":"Fibers","type":"architecture"},{"authors":null,"categories":null,"content":" Actors represent the main unit of logic in the Actor Model. They are transactional, asynchronous and safe. When you work with actors, you have the following guarantees:\n A single actor will process a single message at a time. For example, if you call a method in an actor two times, you will not process those calls in parallel, but sequentially. A single actor will process messages in order. For example, if you call two different methods in an actor, messages will be processed in the calling order. Actor failures are isolated. If an actor fails because there is a requirement that is not fulfilled (like not having network connection), the exception will not propagate to all actors, but will be managed by the actor supervisor. Slow actors will not block other actors. If an actor is waiting for a response of a server, or from another actor, it will not block other actors, that will be still processing messages.  The process of creating an actor is quite transparent, and a simple task. Actor types are represented with a protocol they understand. A protocol is a set of messages that an actor can actually handle.\nFor example, if we have the following protocol:\nping()  It means that the actor will only understand the message ping without parameters.\nWith the following protocol:\nsayHi(whom) sayBye(whom)  It means that the actor can handle both messages, sayHi and sayBye with a single parameter.\nTo define an Actor protocol, we just need to create a ES6 class that extends Actor.\nconst { Actor } = require('tarant') class Person extends Actor { sayHi(whom) { console.log('Hi', whom) } sayBye(whom) { console.log('Bye', whom) } }  This Actor type Person will handle two messages with the specified logic (just printing something into the console). To instantiate an actor, we need a running actor system. We are going to create an Actor System with the default configuration:\nconst { ActorSystem } = require('tarant') const system = ActorSystem.default()  And to instantiate an actor, we need to call the actorOf method with the Actor protocol that we want to use:\nconst dante = system.actorOf(Person)  And you can call any method of the actor directly, like any other class:\ndante.sayHi('Martin')  Actors with initial state It\u0026rsquo;s common that an actor needs some initial state to work, for example, in our case, we need the person name. Actors can receive any initial state on the constructor, and this state can be passed through actorOf. For example, let\u0026rsquo;s extend our Person protocol to allow having a name.\nclass Person extends Actor { constructor(name) { super() this.name = name } sayHi(whom) { console.log(this.name, ': Hi', whom) } sayBye(whom) { console.log(this.name, ': Bye', whom) } }  When defining the constructor of an Actor, there are two things to consider:\n You need to call the super() constructor. This is a JavaScript rule and it won\u0026rsquo;t work if we don\u0026rsquo;t do it the first thing in your newly created constructor. super() has a parameter id that is the ID of the actor. Actors are uniquely identified by an ID that you can pass through the super constructor (as in super(theIdIWant)). If we don\u0026rsquo;t specify any ID, tarant will create a random UUID for it.  Now that we have our new redefined protocol, we can create a new actor with a name.\nconst dante = system.actorOf(Person, ['Dante'])  Now, calling the sayHi method like in the previous example, will show:\n\u0026gt; Dante : Hi Martin  How calling an Actor works It\u0026rsquo;s important to note that calling an actor method is not a synchronous operation. It\u0026rsquo;s completely asynchronous and they always return promises. When you call a method on an actor, the actor will add a new message to it\u0026rsquo;s mailbox, and will be processing messages in the mailbox until it\u0026rsquo;s empty.\nYou can find more information of the architecture in the architecture page.\n","date":1543363200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1543363200,"objectID":"ea2746baa624a10c010e5226f911b8e3","permalink":"http://tarantx.github.io/tutorial/how-to-create-an-actor/","publishdate":"2018-11-28T00:00:00Z","relpermalink":"/tutorial/how-to-create-an-actor/","section":"tutorial","summary":"Actors represent the main unit of logic in the Actor Model. They are transactional, asynchronous and safe. When you work with actors, you have the following guarantees:\n A single actor will process a single message at a time. For example, if you call a method in an actor two times, you will not process those calls in parallel, but sequentially. A single actor will process messages in order. For example, if you call two different methods in an actor, messages will be processed in the calling order.","tags":null,"title":"How To Create an Actor","type":"tutorial"},{"authors":null,"categories":null,"content":"Mailboxes are a queue of messages with guaranteed ordering. Mailboxes have a set of useful properties that make them really powerful:\n Mailboxes are partitioned. It means that messages are distributed through partitions, and subscribers can read from different partitions. Mailboxes are dynamic. You can subscribe and unsubscribe from a mailbox many times. They guarantee ordered/only once delivery. Even if an actor can process the same message more than once (depending on the recovery strategy), the message will be only delivered once by the mailbox.  ","date":1543363200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1543363200,"objectID":"3e4e3fcaef44548cd5652c05265eb910","permalink":"http://tarantx.github.io/architecture/mailboxes/","publishdate":"2018-11-28T00:00:00Z","relpermalink":"/architecture/mailboxes/","section":"architecture","summary":"Mailboxes are a queue of messages with guaranteed ordering. Mailboxes have a set of useful properties that make them really powerful:\n Mailboxes are partitioned. It means that messages are distributed through partitions, and subscribers can read from different partitions. Mailboxes are dynamic. You can subscribe and unsubscribe from a mailbox many times. They guarantee ordered/only once delivery. Even if an actor can process the same message more than once (depending on the recovery strategy), the message will be only delivered once by the mailbox.","tags":null,"title":"Mailboxes","type":"architecture"},{"authors":null,"categories":null,"content":"Materializers are hooks over the lifecycle of an actor. They are used to add implicit infrastructure logic to an actor. Some use case of materializers are, actually, two main tarant modules tarant-vue and tarant-local-storage that let us render actors and save their state in the local storage of the browser, for later recovery.\nA materializer can implement the following methods:\n onInitialize(actor: Actor) when the actor is first created. onBeforeMessage(actor: Actor, message: ActorMessage): void when the actor is going to process a message. onAfterMessage(actor: Actor, message: ActorMessage): void after a message has been processed succesfully. onError(actor: Actor, message: ActorMessage, error: any): void when processing a message failed. You can not recover from the error from here, for that, you need to use supervisors.  ","date":1543363200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1543363200,"objectID":"5a804dbdb64522f6c7787ef0cd106953","permalink":"http://tarantx.github.io/architecture/materializers/","publishdate":"2018-11-28T00:00:00Z","relpermalink":"/architecture/materializers/","section":"architecture","summary":"Materializers are hooks over the lifecycle of an actor. They are used to add implicit infrastructure logic to an actor. Some use case of materializers are, actually, two main tarant modules tarant-vue and tarant-local-storage that let us render actors and save their state in the local storage of the browser, for later recovery.\nA materializer can implement the following methods:\n onInitialize(actor: Actor) when the actor is first created. onBeforeMessage(actor: Actor, message: ActorMessage): void when the actor is going to process a message.","tags":null,"title":"Materializers","type":"architecture"},{"authors":null,"categories":null,"content":"Resolvers let us find actors that have been persisted in external systems, like databases or storages. One example of resolver, is the tarant-local-storage module, which let us recover actors that have been persisted in the local storage, without losing information.\nResolvers must implement the following method:\n resolveActorById(id: string): Promise\u0026lt;Actor\u0026gt;. If the actor exists in the storage, return a promise of the configured actor, if not, returns a promise with undefined.  ","date":1543363200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1543363200,"objectID":"8115db5612b3e89c9c262c92733e62aa","permalink":"http://tarantx.github.io/architecture/resolvers/","publishdate":"2018-11-28T00:00:00Z","relpermalink":"/architecture/resolvers/","section":"architecture","summary":"Resolvers let us find actors that have been persisted in external systems, like databases or storages. One example of resolver, is the tarant-local-storage module, which let us recover actors that have been persisted in the local storage, without losing information.\nResolvers must implement the following method:\n resolveActorById(id: string): Promise\u0026lt;Actor\u0026gt;. If the actor exists in the storage, return a promise of the configured actor, if not, returns a promise with undefined.","tags":null,"title":"Resolvers","type":"architecture"},{"authors":null,"categories":null,"content":" Supervisors are the responsible of handling actor failures and deciding the strategy to recover. There are two types of supervisors.\nTop Level Supervisor The Top Level Supervisor is an object that implements the IActorSupervisor interface. The Actor System delegates all errors to the top level supervisor.\nActor Supervisor Actors behalf as supervisors of their child actors. When a child actor fails, the parent will decide which strategy to follow to recover. When the parent actor doesn\u0026rsquo;t define the supervision strategy, it will be delegated to the parent of the parent, and so on. If the actor is a root actor (created by the Actor System itself), the error will be delegated to the top level supervisor.\nSupervision Strategies There are three supervision strategies:\n drop-message: the actor drops the message that we failed to process. retry-message: the actor retries the message that we failed to process. kill-actor: the actor that failed is freed, and all information discarded.  ","date":1543363200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1543363200,"objectID":"9c945928ffa15d227bb3cb80280a06df","permalink":"http://tarantx.github.io/architecture/supervisors/","publishdate":"2018-11-28T00:00:00Z","relpermalink":"/architecture/supervisors/","section":"architecture","summary":"Supervisors are the responsible of handling actor failures and deciding the strategy to recover. There are two types of supervisors.\nTop Level Supervisor The Top Level Supervisor is an object that implements the IActorSupervisor interface. The Actor System delegates all errors to the top level supervisor.\nActor Supervisor Actors behalf as supervisors of their child actors. When a child actor fails, the parent will decide which strategy to follow to recover.","tags":null,"title":"Supervisors","type":"architecture"},{"authors":null,"categories":null,"content":"Sometimes creating a whole actor is not needed because the problem to solve is relatively simple and a set of functions is enough. Tarant contemplates this scenario allowing the developer to write function actors, that benefit from some of the properties of actors, but are simpler.\n They are asynchronous and non-blocking They can be composed They partially benefit from materializers  However, there are some drawbacks compared to normal actors:\n They can not subscribe to topics They are stateless, so some materializers won\u0026rsquo;t work They must return promises or nothing at all (like callbacks)  To create an actor function, you need a running actor system:\nconst system = ActorSystem.default()  And then wrap the function calling the functionFor method in the system:\nconst sumActor = system.functionFor(async (a, b) =\u0026gt; a + b)  And you can call it as a normal async function:\nconst result = await sumActor(5, 15) expect(result).toBe(20)  ","date":1543276800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1543276800,"objectID":"4d6b14e736bf91eed637b6764d5cc9d4","permalink":"http://tarantx.github.io/tutorial/how-to-create-a-function-actor/","publishdate":"2018-11-27T00:00:00Z","relpermalink":"/tutorial/how-to-create-a-function-actor/","section":"tutorial","summary":"Sometimes creating a whole actor is not needed because the problem to solve is relatively simple and a set of functions is enough. Tarant contemplates this scenario allowing the developer to write function actors, that benefit from some of the properties of actors, but are simpler.\n They are asynchronous and non-blocking They can be composed They partially benefit from materializers  However, there are some drawbacks compared to normal actors:","tags":null,"title":"How to Create a Function Actor","type":"tutorial"},{"authors":null,"categories":null,"content":" Tarant implements a basic, but powerful pubsub mechanism named topics. A topic is a stream of events that are sent to all subscribers of the topic. For example, if we send the event hello to the topic salutations, and there are three subscribers, all of them will receive a copy of hello.\nMessages send through a topic are guaranteed to be processed only once by the topic and in order.\nHow to create a Topic A Topic, like an actor, has a protocol. All subscribers to that topic need to satisfy also the protocol of the topic. For example, if we have a protocol:\nfoo() bar()  All subscribers of the topic will need to implement foo() and bar().\nSo first, we need to define a protocol:\nclass UserEvents { onUserRegistered(username) {} }  And then we need to create an actor protocol that satisfies the UserEvents protocol.\nclass EmailSender extends Actor { onUserRegistered(username) { sendEmailTo(username) } }  Now we can create a topic for that protocol and subscribe to it:\nconst topic = Topic.for(system, 'user-events-topic', UserEvents) topic.subscribe(system.actorOf(EmailSender))  For sending a message through a topic, we need to call the method that represents the message:\ntopic.onUserRegistered('dante')  And all subscribers of that topic will receive the message. Is worth to note that a topic is also an actor, so all properties of an actor also apply for topics.\nFore a example on how to use PubSub, you can see the showcase about pubsub.\n","date":1543190400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1543190400,"objectID":"dc99945c45ab91b09b704e470a5a824a","permalink":"http://tarantx.github.io/tutorial/how-to-apply-pubsub-patterns/","publishdate":"2018-11-26T00:00:00Z","relpermalink":"/tutorial/how-to-apply-pubsub-patterns/","section":"tutorial","summary":"Tarant implements a basic, but powerful pubsub mechanism named topics. A topic is a stream of events that are sent to all subscribers of the topic. For example, if we send the event hello to the topic salutations, and there are three subscribers, all of them will receive a copy of hello.\nMessages send through a topic are guaranteed to be processed only once by the topic and in order.","tags":null,"title":"How To Apply Pub Sub Patterns","type":"tutorial"},{"authors":null,"categories":null,"content":" Motivation Provide the capabilities to actors to be render using the vue framework.\nInstallation add it to your project using npm install tarant-vue --save or yarn add tarant-vue\nUsage Extend the vue actor with a template and the properties to bind to the id of the actor will relate to the html component id\nimport { VueActor } from \u0026quot;tarant-vue\u0026quot;; export default class AppActor extends VueActor { constructor() { super(\u0026quot;#app\u0026quot;) this.schedule(1000, this.incrementCounter, []) } private incrementCounter(): void { this.counter++; } private counter = 0; readonly template : string = \u0026quot;\u0026lt;div\u0026gt;counter: {{counter}}\u0026lt;/div\u0026gt;\u0026quot; }  Initialize the actor system with the provided materializer\nimport { ActorSystem, ActorSystemConfigurationBuilder } from 'tarant' import AppActor from './Actor/AppActor'; import { VueRenderer } from 'tarant-vue'; window.onload = () =\u0026gt; { const system = ActorSystem.for(ActorSystemConfigurationBuilder.define() .withMaterializer(new VueRenderer()) .done()) system.actorOf(AppActor) }  Created my free logo at LogoMakr.com ","date":1540771200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1540771200,"objectID":"1f0ae98a4b089c617bc051ca2f31e094","permalink":"http://tarantx.github.io/modules/tarant-vue/","publishdate":"2018-10-29T00:00:00Z","relpermalink":"/modules/tarant-vue/","section":"modules","summary":"Motivation Provide the capabilities to actors to be render using the vue framework.\nInstallation add it to your project using npm install tarant-vue --save or yarn add tarant-vue\nUsage Extend the vue actor with a template and the properties to bind to the id of the actor will relate to the html component id\nimport { VueActor } from \u0026quot;tarant-vue\u0026quot;; export default class AppActor extends VueActor { constructor() { super(\u0026quot;#app\u0026quot;) this.","tags":["vue","materializer","tarant"],"title":" Tarant Vue","type":"modules"},{"authors":null,"categories":null,"content":" Motivation Usually complex applications need to store offline part of the state, so it can be synced back or reused later. This module lets tarant store your actors serialized in the local storage and recovered implicitly.\nInstallation Add it to your project using npm install tarant-local-storage --save or yarn add tarant-local-storage\nUsage You need to mark which classes need to be exported first. Usually this is done with the LocalStoragePersisted\nclass decorator.\nimport { Actor } from \u0026quot;tarant\u0026quot;; import { LocalStoragePersisted } from \u0026quot;tarant-local-storage\u0026quot;; export default class MyPersistedActor extends Actor { ... } LocalStoragePersisted(\u0026quot;MyPersistedActor\u0026quot;, MyPersistedActor) // NameOfThePersistedClass (unique), Class constructor  And then add the repository as a materializer and as a resolver:\nimport { ActorSystem, ActorSystemConfigurationBuilder } from 'tarant' import MyPersistedActor from './actor'; import { LocalStoragePersisted, LocalStorageRepository } from 'tarant-local-storage'; window.onload = () =\u0026gt; { const repository = new LocalStorageRepository() const system = ActorSystem.for(ActorSystemConfigurationBuilder.define() .withMaterializers([repository]) .withResolvers([repository]) .done()) system.actorOf(MyPersistedActor) }  Created my free logo at LogoMakr.com ","date":1535500800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1535500800,"objectID":"d300c6e99609574157d7ab82214f5dc9","permalink":"http://tarantx.github.io/modules/tarant-local-storage/","publishdate":"2018-08-29T00:00:00Z","relpermalink":"/modules/tarant-local-storage/","section":"modules","summary":"Motivation Usually complex applications need to store offline part of the state, so it can be synced back or reused later. This module lets tarant store your actors serialized in the local storage and recovered implicitly.\nInstallation Add it to your project using npm install tarant-local-storage --save or yarn add tarant-local-storage\nUsage You need to mark which classes need to be exported first. Usually this is done with the LocalStoragePersisted","tags":["persist","materializer","resolver","tarant"],"title":" Tarant Local Storage","type":"modules"},{"authors":null,"categories":null,"content":" Motivation Provide the capabilities to actors to synchronize with a backend.\nInstallation add it to your project using npm install tarant-sync-client --save or yarn add tarant-sync-client\nUsage Initialize the sync client with the configuration you desire and add it to your actor system as both a materializxer and a resolver\nimport { RemoteResolverMaterializer } from \u0026quot;tarant-sync-client\u0026quot;; import AppActor from '../AppActor'; const config : any = { sync: { active: true, delay: 1000 }, paths: { pull: \u0026quot;/pull\u0026quot;, push: \u0026quot;/push\u0026quot;, }, actorTypes: { AppActor } } const remote = new RemoteResolverMaterializer(config) const system = ActorSystem.for(ActorSystemConfigurationBuilder.define() .withMaterializers([remote]) .withResolvers([remote]) .done())  your actors will require to implement IUpdatable (UpdateFrom) and IExportable (toJson)\nimport { Actor } from \u0026quot;tarant\u0026quot;; import { IUpdatable, IExportable } from \u0026quot;tarant-sync-client\u0026quot; export default class AppActor extends Actor implements IUpdatable, IExportable { constructor(name: string) { super(name) } addOne() { this.counter++ } toJson(){ return { id: this.id, type:\u0026quot;AppActor\u0026quot;, counter: this.counter } } updateFrom({ counter }: any): void { this.counter = counter } private counter = 1; }  confiuration options  sync.active: boolean value defining if there should be live updates pull from the backend sync.delay: period of time in miliseconds between updates from the backend paths.pull: path to endpoint for pulling data from the backend paths.push: path to endpoint for pushing data to the backend ActorTypes: objects registering the type of actors that should be sync with the backend  Created my free logo at LogoMakr.com ","date":1514505600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1514505600,"objectID":"46ee4fb0cdfc432a371297f19fd71ad0","permalink":"http://tarantx.github.io/modules/tarant-sync-client/","publishdate":"2017-12-29T00:00:00Z","relpermalink":"/modules/tarant-sync-client/","section":"modules","summary":"Motivation Provide the capabilities to actors to synchronize with a backend.\nInstallation add it to your project using npm install tarant-sync-client --save or yarn add tarant-sync-client\nUsage Initialize the sync client with the configuration you desire and add it to your actor system as both a materializxer and a resolver\nimport { RemoteResolverMaterializer } from \u0026quot;tarant-sync-client\u0026quot;; import AppActor from '../AppActor'; const config : any = { sync: { active: true, delay: 1000 }, paths: { pull: \u0026quot;/pull\u0026quot;, push: \u0026quot;/push\u0026quot;, }, actorTypes: { AppActor } } const remote = new RemoteResolverMaterializer(config) const system = ActorSystem.","tags":["sync","materializer","resolver","tarant"],"title":" Tarant Sync Client","type":"modules"},{"authors":null,"categories":null,"content":" Motivation remote-sync server for bindings clients using routers or tarant-sync-router-express\nInstallation add it to your project using npm install tarant-sync-router-express --save or yarn add tarant-sync-router-express\nUsage initialize your controllers/routers by calling the SyncController with the actor system and the wanted configuration. Adding them to your express app.\nimport SyncController from \u0026quot;tarant-sync-router-express\u0026quot; import { ActorSystem, ActorSystemConfigurationBuilder } from 'tarant' import AppActor from '../AppActor' const app: express.Application = express() const port: number = 3002 const config : any = { paths: { pull: \u0026quot;/pull\u0026quot;, push: \u0026quot;/push\u0026quot;, }, actorTypes: { AppActor } } const system : any = ActorSystem.for(ActorSystemConfigurationBuilder.define().done()) app.use(SyncController(system, config)) app.listen(port, () =\u0026gt; { console.log(`Listening at http://localhost:${port}/`) })  your actors will require to implement IUpdatable (UpdateFrom) and IExportable (toJson)\nimport { Actor } from \u0026quot;tarant\u0026quot;; import { IUpdatable, IExportable } from \u0026quot;tarant-sync-router-express\u0026quot; export default class AppActor extends Actor implements IUpdatable, IExportable { constructor(name: string) { super(name) } addOne() { this.counter++ } toJson(){ return { id: this.id, type:\u0026quot;AppActor\u0026quot;, counter: this.counter } } updateFrom({ counter }: any): void { this.counter = counter } private counter = 1; }  confiuration options  paths.pull: path to endpoint for pulling data from the backend paths.push: path to endpoint for pushing data to the backend ActorTypes: objects registering the type of actors that should be sync with the backend  Created my free logo at LogoMakr.com ","date":1509235200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1509235200,"objectID":"098dcc7325590e31e9274e48e862f4e0","permalink":"http://tarantx.github.io/modules/tarant-sync-router-express/","publishdate":"2017-10-29T00:00:00Z","relpermalink":"/modules/tarant-sync-router-express/","section":"modules","summary":"Motivation remote-sync server for bindings clients using routers or tarant-sync-router-express\nInstallation add it to your project using npm install tarant-sync-router-express --save or yarn add tarant-sync-router-express\nUsage initialize your controllers/routers by calling the SyncController with the actor system and the wanted configuration. Adding them to your express app.\nimport SyncController from \u0026quot;tarant-sync-router-express\u0026quot; import { ActorSystem, ActorSystemConfigurationBuilder } from 'tarant' import AppActor from '../AppActor' const app: express.Application = express() const port: number = 3002 const config : any = { paths: { pull: \u0026quot;/pull\u0026quot;, push: \u0026quot;/push\u0026quot;, }, actorTypes: { AppActor } } const system : any = ActorSystem.","tags":["sync","materializer","resolver","tarant"],"title":" Tarant Sync Client","type":"modules"},{"authors":null,"categories":null,"content":" Motivation Provide the capabilities to actors on the backend to be persisted using waterline adapters.\nInstallation add it to your project using npm install tarant-db-persist --save or yarn add tarant-db-persist\nUsage Initialize the sync client with the waterline adapter from the persist storage you will be interested on\nimport { ActorSystem, ActorSystemConfigurationBuilder } from 'tarant'; import * as diskAdapter from 'sails-disk'; import { PersistResolverMaterializer } from 'tarant-db-persist'; import AppActor from '../AppActor'; const config = { adapter: diskAdapter, actorTypes: { AppActor } }; const persister = await PersistMaterializer.create(config) const system : any = ActorSystem.for(ActorSystemConfigurationBuilder.define() .withMaterializers([persister]) .withResolvers([persister]) .done())  your actors will require to implement IUpdatable (UpdateFrom) and IExportable (toJson)\nimport { Actor } from \u0026quot;tarant\u0026quot;; import { IUpdatable, IExportable } from \u0026quot;tarant-db-persist\u0026quot; export default class AppActor extends Actor implements IUpdatable, IExportable { constructor(name: string) { super(name) } addOne() { this.counter++ } toJson(){ return { id: this.id, type:\u0026quot;AppActor\u0026quot;, counter: this.counter } } updateFrom({ counter }: any): void { this.counter = counter } private counter = 1; }  Created my free logo at LogoMakr.com ","date":1503964800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1503964800,"objectID":"bbf21c12b84a404b6f46d3ffbe5dbd59","permalink":"http://tarantx.github.io/modules/tarant-db-persist/","publishdate":"2017-08-29T00:00:00Z","relpermalink":"/modules/tarant-db-persist/","section":"modules","summary":"Motivation Provide the capabilities to actors on the backend to be persisted using waterline adapters.\nInstallation add it to your project using npm install tarant-db-persist --save or yarn add tarant-db-persist\nUsage Initialize the sync client with the waterline adapter from the persist storage you will be interested on\nimport { ActorSystem, ActorSystemConfigurationBuilder } from 'tarant'; import * as diskAdapter from 'sails-disk'; import { PersistResolverMaterializer } from 'tarant-db-persist'; import AppActor from '.","tags":["persist","materializer","resolver","tarant"],"title":" Tarant DB Persist","type":"modules"}]